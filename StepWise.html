<!DOCTYPE html>
<html>
<head>
    <title>StepWise</title>
    <meta charset="UTF-8">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            padding: 0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
            background: white;
            overflow: hidden;
        }

        #controls {
            width: 280px;
            min-width: 280px;
            background: #f8f9fa;
            padding: 20px;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
        }

        #controls h2 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.3em;
            font-weight: 600;
        }

        #controls .control-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }

        #controls .control-section:last-child {
            border-bottom: none;
        }

        #controls .section-title {
            font-size: 0.85em;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        #tasklist {
            flex: 1;
            padding: 30px;
            overflow: auto;
            height: 100vh;
            outline: none;
        }

        .node {
            padding: 8px 12px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: flex-start;
            gap: 8px;
            font-weight: 500;
            font-size: 0.95em;
            transition: all 0.2s ease;
            user-select: none;
        }

        .node:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .expand-collapse-btn {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            padding: 0;
            margin: 0;
            margin-top: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            line-height: 1;
            background: rgba(0,0,0,0.1);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .expand-collapse-btn:hover {
            background: rgba(0,0,0,0.2);
            transform: scale(1.1);
        }

        .node-text {
            flex-grow: 1;
            min-width: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
        }

        .node-actions {
            flex-shrink: 0;
            display: flex;
            gap: 5px;
            align-items: flex-start;
            padding-top: 2px;
        }

        .leaf.new {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            color: #495057;
        }
        .leaf.in-progress {
            background: linear-gradient(135deg, #fff3cd 0%, #ffc107 100%);
            color: #856404;
        }
        .leaf.done {
            background: linear-gradient(135deg, #d4edda 0%, #28a745 100%);
            color: #155724;
        }
        .parent.new {
            background: linear-gradient(135deg, #d6d8db 0%, #ced4da 100%);
            color: #343a40;
            font-weight: 600;
        }
        .parent.in-progress {
            background: linear-gradient(135deg, #ffe69c 0%, #ffca2c 100%);
            color: #664d03;
            font-weight: 600;
        }
        .parent.done {
            background: linear-gradient(135deg, #badbcc 0%, #198754 100%);
            color: #0a3622;
            font-weight: 600;
        }

        .node-container {
            border: 2px solid #e9ecef;
            padding: 8px;
            margin: 8px 0;
            border-radius: 10px;
            display: block;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
        }

        .node-container.selected {
            border: 2px solid #667eea;
            background: #f8f9ff;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .node-container.dragging {
            opacity: 0.6;
            transform: scale(0.98);
            background-color: #f8f9fa;
        }

        .node-container.drag-over {
            border: 2px dashed #667eea;
            background-color: #f0f4ff;
            transform: scale(1.02);
        }

        button {
            margin: 5px 0;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9em;
            transition: all 0.2s ease;
            background: #667eea;
            color: white;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .node button {
            padding: 4px 8px;
            font-size: 0.8em;
            background: rgba(0,0,0,0.1);
            color: inherit;
            margin-left: 8px;
        }

        .node button:hover {
            background: rgba(0,0,0,0.2);
        }

        input, textarea, select {
            margin: 5px 0;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9em;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        #controls button, #controls input {
            width: 100%;
        }

        #searchBox {
            width: 100%;
            margin-bottom: 10px;
        }

        #projectSelect {
            width: 100%;
            margin: 5px 0;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9em;
            font-family: inherit;
            background: #fff;
            color: #212529;
            cursor: pointer;
        }
        #projectSelect:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .snapshot-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 2px;
            border-bottom: 1px solid #dee2e6;
            font-size: 11px;
            gap: 4px;
        }
        .snapshot-item:last-child { border-bottom: none; }
        .snapshot-info { display: flex; flex-direction: column; flex: 1; min-width: 0; }
        .snapshot-name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .snapshot-meta { color: #6c757d; font-size: 10px; }
        .snapshot-actions { display: flex; gap: 2px; flex-shrink: 0; }
        .snapshot-actions button { padding: 2px 5px; font-size: 11px; }

        .keyboard-hint {
            font-size: 0.75em;
            color: #6c757d;
            margin-top: 15px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 6px;
            line-height: 1.6;
        }

        .keyboard-hint kbd {
            background: white;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #ced4da;
            font-family: monospace;
            font-size: 0.9em;
        }

        select {
            cursor: pointer;
        }

        .node-description {
            font-size: 0.85em;
            color: #6c757d;
            margin: 5px 0 5px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-style: italic;
            display: none;
        }

        .node-description.visible {
            display: block;
        }

        .undo-redo-container {
            display: flex;
            gap: 5px;
        }

        .undo-redo-container button {
            flex: 1;
        }

        .stats-container {
            background: #e7f3ff;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stats-container .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .stats-container .stat-label {
            color: #495057;
            font-weight: 500;
        }

        .stats-container .stat-value {
            color: #667eea;
            font-weight: 600;
        }

        .highlight {
            background-color: #fff176 !important;
            animation: highlightFade 2s ease-in-out;
        }

        @keyframes highlightFade {
            0% { background-color: #fff176; }
            100% { background-color: transparent; }
        }

        .hidden {
            display: none !important;
        }

        #importFile {
            padding: 8px;
            background: white;
        }

        /* Timeline View Styles */
        .view-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .view-toggle button {
            flex: 1;
            padding: 8px 12px;
            font-size: 0.85em;
        }

        .view-toggle button.active {
            background: #5568d3;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .timeline-container {
            position: relative;
            min-height: 200px;
            padding: 20px;
            overflow-x: auto;
        }

        .timeline-lane {
            position: relative;
            height: 40px;
            margin: 4px 0;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .timeline-bar {
            position: absolute;
            height: 32px;
            top: 4px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 2px solid transparent;
        }

        .timeline-bar:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .timeline-bar.selected {
            border: 2px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .timeline-bar.leaf.new {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            color: #495057;
        }

        .timeline-bar.leaf.in-progress {
            background: linear-gradient(135deg, #fff3cd 0%, #ffc107 100%);
            color: #856404;
        }

        .timeline-bar.leaf.done {
            background: linear-gradient(135deg, #d4edda 0%, #28a745 100%);
            color: #155724;
        }

        .timeline-bar.parent.new {
            background: linear-gradient(135deg, #d6d8db 0%, #ced4da 100%);
            color: #343a40;
        }

        .timeline-bar.parent.in-progress {
            background: linear-gradient(135deg, #ffe69c 0%, #ffca2c 100%);
            color: #664d03;
        }

        .timeline-bar.parent.done {
            background: linear-gradient(135deg, #badbcc 0%, #198754 100%);
            color: #0a3622;
        }

        .timeline-header {
            display: flex;
            margin-bottom: 10px;
            padding: 0 20px;
            font-size: 0.8em;
            color: #6c757d;
        }

        .timeline-scale {
            display: flex;
            flex: 1;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 5px;
        }

        .timeline-scale-mark {
            flex: 1;
            text-align: center;
            border-left: 1px solid #dee2e6;
        }

        .timeline-scale-mark:first-child {
            border-left: none;
        }

        .timeline-lanes-container {
            position: relative;
        }

        .timeline-grid-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #e9ecef;
            pointer-events: none;
        }

        /* Help Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
        }

        .modal-header h2 {
            margin: 0;
            color: #495057;
            font-size: 1.5em;
        }

        .modal-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .shortcuts-section {
            margin-bottom: 20px;
        }

        .shortcuts-section h3 {
            color: #667eea;
            font-size: 1.1em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .shortcut-item:last-child {
            border-bottom: none;
        }

        .shortcut-keys {
            display: flex;
            gap: 5px;
        }

        .shortcut-keys kbd {
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            font-family: monospace;
            font-size: 0.9em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .shortcut-description {
            color: #495057;
            font-size: 0.95em;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>StepWise</h2>

            <div class="control-section">
                <div class="section-title">Project</div>
                <select id="projectSelect" onchange="switchProject(this.value)"></select>
                <div style="display:flex; gap:4px; margin-top:4px;">
                    <button onclick="createNewProject()" style="flex:1; padding:6px 4px; font-size:0.8em;">New</button>
                    <button onclick="renameCurrentProject()" style="flex:1; padding:6px 4px; font-size:0.8em;">Rename</button>
                    <button onclick="deleteCurrentProject()" style="flex:1; padding:6px 4px; font-size:0.8em;">Delete</button>
                </div>
            </div>

            <div class="stats-container">
                <div class="stat-item">
                    <span class="stat-label">Total Nodes:</span>
                    <span class="stat-value" id="totalNodes">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Completed:</span>
                    <span class="stat-value" id="completedNodes">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Progress:</span>
                    <span class="stat-value" id="overallProgress">0%</span>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">View</div>
                <div class="view-toggle">
                    <button id="hierarchyViewBtn" class="active" onclick="setViewMode('hierarchy')">üìã Hierarchy</button>
                    <button id="timelineViewBtn" onclick="setViewMode('timeline')">üìä Timeline</button>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Search</div>
                <input type="text" id="searchBox" placeholder="Search nodes..." oninput="searchNodes()">
            </div>

            <div class="control-section">
                <div class="section-title">Actions</div>
                <div class="undo-redo-container">
                    <button onclick="undo()" id="undoBtn" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
                    <button onclick="redo()" id="redoBtn" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
                </div>
                <button onclick="addNode()">‚ûï Add Node</button>
                <button onclick="renameNode()">‚úèÔ∏è Rename Node</button>
                <button onclick="addDescription()">üìù Add Description</button>
                <button onclick="removeNode()">üóëÔ∏è Remove Node</button>
            </div>

            <div class="control-section">
                <div class="section-title">File Operations</div>
                <button onclick="exportToJson()">üíæ Export to JSON</button>
                <label for="importFile" style="display: block;">
                    <input type="file" id="importFile" accept=".json" onchange="importFromJson()">
                </label>
            </div>

            <div class="control-section">
                <div class="section-title">Snapshots</div>
                <div style="display:flex; gap:4px; align-items:center;">
                    <input type="text" id="snapshotName" placeholder="Snapshot name..."
                           style="flex:1; padding:4px 6px; font-size:12px; border:1px solid #ced4da; border-radius:4px; background:#fff; color:#212529;">
                    <button onclick="saveSnapshot()" title="Save snapshot">üíæ Save</button>
                </div>
                <div id="snapshotList" style="margin-top:6px; max-height:180px; overflow-y:auto;"></div>
            </div>

            <div class="control-section">
                <button onclick="openHelpModal()">‚ùì Help & Shortcuts</button>
            </div>
        </div>
        <div id="tasklist" tabindex="0"></div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
                <button class="modal-close" onclick="closeHelpModal()">‚úï</button>
            </div>

            <div class="shortcuts-section">
                <h3>Navigation</h3>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>‚Üë</kbd> <kbd>‚Üì</kbd></div>
                    <div class="shortcut-description">Navigate to previous/next sibling</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>‚Üê</kbd></div>
                    <div class="shortcut-description">Go to parent node</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>‚Üí</kbd></div>
                    <div class="shortcut-description">Go to first child node</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Space</kbd></div>
                    <div class="shortcut-description">Expand/collapse node</div>
                </div>
            </div>

            <div class="shortcuts-section">
                <h3>Editing</h3>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Enter</kbd></div>
                    <div class="shortcut-description">Add child node</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>F2</kbd></div>
                    <div class="shortcut-description">Rename selected node</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Del</kbd></div>
                    <div class="shortcut-description">Remove selected node</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd></div>
                    <div class="shortcut-description">Set status (new/in-progress/done)</div>
                </div>
            </div>

            <div class="shortcuts-section">
                <h3>Reordering</h3>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>‚Üë</kbd></div>
                    <div class="shortcut-description">Move node up</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>‚Üì</kbd></div>
                    <div class="shortcut-description">Move node down</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Home</kbd></div>
                    <div class="shortcut-description">Move node to first position</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>End</kbd></div>
                    <div class="shortcut-description">Move node to last position</div>
                </div>
            </div>

            <div class="shortcuts-section">
                <h3>General</h3>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Z</kbd></div>
                    <div class="shortcut-description">Undo</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>Y</kbd></div>
                    <div class="shortcut-description">Redo</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>F</kbd></div>
                    <div class="shortcut-description">Focus search box</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>Ctrl</kbd> + <kbd>H</kbd></div>
                    <div class="shortcut-description">Show/hide this help</div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-keys"><kbd>ESC</kbd></div>
                    <div class="shortcut-description">Close help modal</div>
                </div>
            </div>

            <div class="shortcuts-section">
                <h3>Mouse Actions</h3>
                <div class="shortcut-item">
                    <div class="shortcut-description" style="font-style: italic;">
                        Double-click node name to edit inline
                    </div>
                </div>
                <div class="shortcut-item">
                    <div class="shortcut-description" style="font-style: italic;">
                        Drag and drop nodes to reorganize hierarchy
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Node {
            constructor(name, isLeaf = true, children = [], collapsed = false, description = '') {
                this.name = name;
                this.isLeaf = isLeaf;
                this.children = children;
                this.status = isLeaf ? 'new' : this.calculateStatus();
                this.collapsed = collapsed;
                this.description = description;
            }

            calculateStatus() {
                if (this.isLeaf) return this.status;
                if (!this.children.length) return 'new';
                
                const childStatuses = this.children.map(child => child.status);
                if (childStatuses.every(s => s === 'done')) return 'done';
                if (childStatuses.some(s => s === 'in-progress') || 
                    childStatuses.some(s => s === 'done')) return 'in-progress';
                return 'new';
            }

            calculateCompletionPercentage() {
                if (this.isLeaf) return this.status === 'done' ? 100 : 0;
                if (!this.children.length) return 0;

                let totalLeafNodes = 0;
                let completedLeafNodes = 0;

                function countLeafNodes(node) {
                    if (node.isLeaf) {
                        totalLeafNodes++;
                        if (node.status === 'done') completedLeafNodes++;
                    } else {
                        node.children.forEach(countLeafNodes);
                    }
                }

                countLeafNodes(this);
                return totalLeafNodes > 0 ? Math.round((completedLeafNodes / totalLeafNodes) * 100) : 0;
            }

            countTasksByStatus() {
                if (this.isLeaf) {
                    return {
                        new: this.status === 'new' ? 1 : 0,
                        inProgress: this.status === 'in-progress' ? 1 : 0,
                        done: this.status === 'done' ? 1 : 0
                    };
                }

                let counts = { new: 0, inProgress: 0, done: 0 };

                function countByStatus(node) {
                    if (node.isLeaf) {
                        if (node.status === 'new') counts.new++;
                        else if (node.status === 'in-progress') counts.inProgress++;
                        else if (node.status === 'done') counts.done++;
                    } else {
                        node.children.forEach(countByStatus);
                    }
                }

                countByStatus(this);
                return counts;
            }
        }

        let taskList = new Node('Root', false);
        let selectedNode = null;
        let draggedNode = null;
        let history = [];
        let historyIndex = -1;
        let maxHistorySize = 50;
        let searchTerm = '';
        let viewMode = 'hierarchy'; // 'hierarchy' or 'timeline'
        let autoScrollInterval = null;
        let activeProjectId = null;

        // Per-project storage key helpers
        function currentKey()   { return `stepwise_proj_${activeProjectId}_current`; }
        function snapshotsKey() { return `stepwise_proj_${activeProjectId}_snapshots`; }

        // Undo/Redo functionality
        function saveState() {
            const state = JSON.stringify(taskList);
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(state);
            if (history.length > maxHistorySize) {
                history.shift();
            } else {
                historyIndex++;
            }
            updateUndoRedoButtons();
            if (activeProjectId !== null) {
                localStorage.setItem(currentKey(), state);
                touchProjectModified();
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                // Refocus for keyboard navigation
                setTimeout(() => document.getElementById('tasklist').focus(), 0);
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                // Refocus for keyboard navigation
                setTimeout(() => document.getElementById('tasklist').focus(), 0);
            }
        }

        function restoreState(state) {
            taskList = convertToNode(JSON.parse(state));
            selectedNode = null;
            updateParentStatuses(taskList);
            renderView();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // Search functionality
        function searchNodes() {
            searchTerm = document.getElementById('searchBox').value.toLowerCase();
            if (searchTerm) {
                expandAncestorsOfMatches(taskList);
            }
            renderView();
        }

        function expandAncestorsOfMatches(node) {
            if (node.isLeaf || !node.children.length) return false;
            let hasMatch = false;
            for (const child of node.children) {
                if (matchesSearch(child) || expandAncestorsOfMatches(child)) {
                    hasMatch = true;
                }
            }
            if (hasMatch) {
                node.collapsed = false;
            }
            return hasMatch;
        }

        function matchesSearch(node) {
            if (!searchTerm) return true;
            return node.name.toLowerCase().includes(searchTerm) ||
                   (node.description && node.description.toLowerCase().includes(searchTerm));
        }

        function hasMatchingDescendant(node) {
            if (matchesSearch(node)) return true;
            if (!node.isLeaf) {
                return node.children.some(child => hasMatchingDescendant(child));
            }
            return false;
        }

        // View mode toggle
        function setViewMode(mode) {
            viewMode = mode;
            document.getElementById('hierarchyViewBtn').classList.toggle('active', mode === 'hierarchy');
            document.getElementById('timelineViewBtn').classList.toggle('active', mode === 'timeline');
            renderView();
        }

        function renderView() {
            if (viewMode === 'timeline') {
                renderTimelineView();
            } else {
                renderTaskList();
            }
            scrollToSelectedNode();
        }

        function scrollToSelectedNode() {
            if (!selectedNode) return;

            // Give the DOM time to update
            setTimeout(() => {
                const containers = document.querySelectorAll('.node-container.selected, .timeline-bar.selected');
                if (containers.length > 0) {
                    containers[0].scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'nearest'
                    });
                }
            }, 50);
        }

        // Auto-scroll during drag operations
        function startAutoScroll(direction, scrollSpeed = 10) {
            stopAutoScroll();
            const taskListElement = document.getElementById('tasklist');

            autoScrollInterval = setInterval(() => {
                if (direction === 'up') {
                    taskListElement.scrollTop -= scrollSpeed;
                } else if (direction === 'down') {
                    taskListElement.scrollTop += scrollSpeed;
                }
            }, 20);
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
        }

        function handleDragAutoScroll(e) {
            const taskListElement = document.getElementById('tasklist');
            const rect = taskListElement.getBoundingClientRect();
            const mouseY = e.clientY;
            const edgeThreshold = 50; // pixels from edge to trigger auto-scroll
            const fastScrollThreshold = 20; // pixels from edge for faster scrolling

            // Calculate distance from edges
            const distanceFromTop = mouseY - rect.top;
            const distanceFromBottom = rect.bottom - mouseY;

            if (distanceFromTop < edgeThreshold && distanceFromTop > 0) {
                // Near top edge
                const speed = distanceFromTop < fastScrollThreshold ? 20 : 10;
                startAutoScroll('up', speed);
            } else if (distanceFromBottom < edgeThreshold && distanceFromBottom > 0) {
                // Near bottom edge
                const speed = distanceFromBottom < fastScrollThreshold ? 20 : 10;
                startAutoScroll('down', speed);
            } else {
                stopAutoScroll();
            }
        }

        // Timeline View
        function renderTimelineView() {
            const element = document.getElementById('tasklist');
            if (!element) return;
            element.innerHTML = '';

            // Calculate duration for each node (leaf = 1 unit, parent = sum of children)
            const durations = new Map();
            function getDuration(node) {
                if (durations.has(node)) return durations.get(node);
                let dur;
                if (node.isLeaf || !node.children.length) {
                    dur = 1;
                } else {
                    const visibleChildren = searchTerm
                        ? node.children.filter(c => hasMatchingDescendant(c))
                        : node.children;
                    dur = visibleChildren.reduce((sum, child) => sum + getDuration(child), 0) || 1;
                }
                durations.set(node, dur);
                return dur;
            }

            // Calculate start times (children are sequential within parent)
            const startTimes = new Map();
            function assignStartTimes(node, start) {
                startTimes.set(node, start);
                if (!node.isLeaf && node.children.length) {
                    let childStart = start;
                    const visibleChildren = searchTerm
                        ? node.children.filter(c => hasMatchingDescendant(c))
                        : node.children;
                    for (const child of visibleChildren) {
                        assignStartTimes(child, childStart);
                        childStart += getDuration(child);
                    }
                }
            }

            // Assign lanes to leaf nodes and calculate lane spans for parent nodes
            let laneIndex = 0;
            const laneAssignments = new Map();

            function assignLanes(node) {
                if (searchTerm && !hasMatchingDescendant(node)) {
                    return null;
                }

                if (node.isLeaf || !node.children.length) {
                    const lane = laneIndex++;
                    laneAssignments.set(node, { startLane: lane, endLane: lane });
                    return { startLane: lane, endLane: lane };
                }

                let minLane = Infinity;
                let maxLane = -Infinity;

                for (const child of node.children) {
                    const childLanes = assignLanes(child);
                    if (childLanes) {
                        minLane = Math.min(minLane, childLanes.startLane);
                        maxLane = Math.max(maxLane, childLanes.endLane);
                    }
                }

                if (minLane !== Infinity) {
                    laneAssignments.set(node, { startLane: minLane, endLane: maxLane });
                    return { startLane: minLane, endLane: maxLane };
                }
                return null;
            }

            // Process root's children sequentially
            let timeOffset = 0;
            for (const child of taskList.children) {
                if (searchTerm && !hasMatchingDescendant(child)) continue;
                getDuration(child);
                assignStartTimes(child, timeOffset);
                timeOffset += getDuration(child);
                assignLanes(child);
            }

            const totalTimeUnits = timeOffset || 1;
            const unitWidth = 150; // pixels per time unit
            const totalWidth = totalTimeUnits * unitWidth;
            const totalLanes = laneIndex || 1;
            const laneHeight = 48;

            // Create timeline container
            const container = document.createElement('div');
            container.className = 'timeline-container';
            container.style.minWidth = `${totalWidth + 40}px`;

            // Create scale header
            const header = document.createElement('div');
            header.className = 'timeline-header';
            header.style.width = `${totalWidth}px`;
            const scale = document.createElement('div');
            scale.className = 'timeline-scale';
            scale.style.width = `${totalWidth}px`;
            for (let i = 0; i < totalTimeUnits; i++) {
                const mark = document.createElement('div');
                mark.className = 'timeline-scale-mark';
                mark.style.width = `${unitWidth}px`;
                mark.style.minWidth = `${unitWidth}px`;
                mark.style.flex = 'none';
                mark.textContent = `${i + 1}`;
                scale.appendChild(mark);
            }
            header.appendChild(scale);
            container.appendChild(header);

            // Create lanes container
            const lanesContainer = document.createElement('div');
            lanesContainer.className = 'timeline-lanes-container';
            lanesContainer.style.height = `${totalLanes * laneHeight}px`;
            lanesContainer.style.position = 'relative';
            lanesContainer.style.width = `${totalWidth}px`;

            // Add grid lines at each time unit
            for (let i = 1; i < totalTimeUnits; i++) {
                const gridLine = document.createElement('div');
                gridLine.className = 'timeline-grid-line';
                gridLine.style.left = `${i * unitWidth}px`;
                lanesContainer.appendChild(gridLine);
            }

            // Add lane backgrounds
            for (let i = 0; i < totalLanes; i++) {
                const lane = document.createElement('div');
                lane.className = 'timeline-lane';
                lane.style.position = 'absolute';
                lane.style.left = '0';
                lane.style.right = '0';
                lane.style.top = `${i * laneHeight}px`;
                lane.style.height = `${laneHeight - 8}px`;
                lanesContainer.appendChild(lane);
            }

            // Render task bars
            function renderTaskBar(node) {
                if (searchTerm && !hasMatchingDescendant(node)) return;

                const lanes = laneAssignments.get(node);
                if (!lanes) return;
                const start = startTimes.get(node);
                if (start === undefined) return;
                const duration = getDuration(node);

                const bar = document.createElement('div');
                bar.className = `timeline-bar ${node.isLeaf ? 'leaf' : 'parent'} ${node.status}`;
                if (node === selectedNode) bar.classList.add('selected');
                if (searchTerm && matchesSearch(node)) bar.classList.add('highlight');

                // Position based on time
                const left = start * unitWidth + 5;
                const width = duration * unitWidth - 10;
                const top = lanes.startLane * laneHeight + 4;
                const height = (lanes.endLane - lanes.startLane + 1) * laneHeight - 16;

                bar.style.left = `${left}px`;
                bar.style.width = `${width}px`;
                bar.style.top = `${top}px`;
                bar.style.height = `${height}px`;

                // For multi-lane bars, adjust text positioning
                if (lanes.startLane !== lanes.endLane) {
                    bar.style.alignItems = 'flex-start';
                    bar.style.paddingTop = '6px';
                }

                // Bar content
                const completionPercentage = node.calculateCompletionPercentage();
                if (!node.isLeaf) {
                    const taskCounts = node.countTasksByStatus();
                    bar.textContent = `${node.name} (${completionPercentage}%)`;
                    bar.title = `${node.name}\nDuration: ${duration} units\n${taskCounts.new} new, ${taskCounts.inProgress} in-progress, ${taskCounts.done} done`;
                } else {
                    bar.textContent = node.name;
                    bar.title = `${node.name} - ${node.status}`;
                }

                bar.onclick = (e) => {
                    e.stopPropagation();
                    selectedNode = node;
                    renderView();
                    document.getElementById('tasklist').focus();
                };

                lanesContainer.appendChild(bar);

                // Render children
                if (!node.isLeaf) {
                    for (const child of node.children) {
                        renderTaskBar(child);
                    }
                }
            }

            // Render all top-level tasks
            for (const child of taskList.children) {
                renderTaskBar(child);
            }

            container.appendChild(lanesContainer);
            element.appendChild(container);

            updateStats();
            updateUndoRedoButtons();
        }

        // Statistics
        function updateStats() {
            let total = 0;
            let completed = 0;

            function countNodes(node) {
                if (node.isLeaf) {
                    total++;
                    if (node.status === 'done') completed++;
                } else {
                    node.children.forEach(countNodes);
                }
            }

            countNodes(taskList);

            document.getElementById('totalNodes').textContent = total;
            document.getElementById('completedNodes').textContent = completed;
            document.getElementById('overallProgress').textContent =
                total > 0 ? Math.round((completed / total) * 100) + '%' : '0%';
        }

        function renderTaskList(node = taskList, element = document.getElementById('tasklist'), depth = 0) {
            if (!element) {
                console.error('Task list element not found');
                return;
            }
            element.innerHTML = '';

            function createNodeElement(currentNode, currentDepth) {
                // Apply search filter
                if (searchTerm && !hasMatchingDescendant(currentNode)) {
                    return null;
                }

                const container = document.createElement('div');
                container.className = 'node-container';
                container.draggable = true;
                container.dataset.nodeName = currentNode.name;
                if (currentNode === selectedNode) container.classList.add('selected');
                if (searchTerm && matchesSearch(currentNode)) container.classList.add('highlight');

                container.ondragstart = (e) => {
					e.stopPropagation();
					if (draggedNode) return; // ignore this event
                    draggedNode = currentNode;
                    container.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', currentNode.name);
                };

                container.ondragend = () => {
                    container.classList.remove('dragging');
                    draggedNode = null;
                    stopAutoScroll();
                    updateParentStatuses(taskList);
                    saveState();
                    renderView();
                };

                container.ondragover = (e) => {
                    e.preventDefault();
                    handleDragAutoScroll(e);
                };

                container.ondragenter = (e) => {
                    e.preventDefault();
                    if (draggedNode && draggedNode !== currentNode) {
                        container.classList.add('drag-over');
                    }
                };

                container.ondragleave = () => {
                    container.classList.remove('drag-over');
                };

                container.ondrop = (e) => {
                    e.stopPropagation();
					e.preventDefault();
                    container.classList.remove('drag-over');
                    stopAutoScroll();
					console.log(draggedNode.name + " - " + currentNode.name);
                    if (draggedNode && draggedNode !== currentNode && draggedNode !== taskList) {
                        // Find and remove draggedNode from its original parent
                        const originalParent = findParent(taskList, draggedNode);
                        if (originalParent) {
                            const index = originalParent.children.indexOf(draggedNode);
                            if (index !== -1) {
                                originalParent.children.splice(index, 1);
                                if (originalParent.children.length === 0) {
                                    originalParent.isLeaf = true;
                                    originalParent.status = 'new';
                                }
                            }
                        }

                        // Attach draggedNode as a child of currentNode
                        if (currentNode.isLeaf) {
                            currentNode.isLeaf = false;
                            currentNode.status = 'new';
                        }
                        currentNode.children.push(draggedNode);

                        // Update statuses and re-render
                        updateParentStatuses(taskList);
                        renderView();
                    }
                };

                const nodeDiv = document.createElement('div');
                const completionPercentage = currentNode.calculateCompletionPercentage();
                nodeDiv.className = `node ${currentNode.isLeaf ? 'leaf' : 'parent'} ${currentNode.status}`;
                nodeDiv.style.marginLeft = `${currentDepth * 20}px`;

                // Add expand/collapse button on the left
                if (!currentNode.isLeaf && currentNode.children.length) {
                    const collapseBtn = document.createElement('button');
                    collapseBtn.className = 'expand-collapse-btn';
                    collapseBtn.textContent = currentNode.collapsed ? '‚ûï' : '‚ûñ';
                    collapseBtn.onclick = (e) => {
                        e.stopPropagation();
                        currentNode.collapsed = !currentNode.collapsed;
                        renderView();
                        // Refocus for keyboard navigation
                        setTimeout(() => document.getElementById('tasklist').focus(), 0);
                    };
                    nodeDiv.appendChild(collapseBtn);
                }

                // Add node text in the middle
                const nameSpan = document.createElement('span');
                nameSpan.className = 'node-text';

                // For non-leaf nodes, show task counts
                if (!currentNode.isLeaf) {
                    const taskCounts = currentNode.countTasksByStatus();
                    nameSpan.textContent = `${currentNode.name} (${completionPercentage}%, ${taskCounts.new} new, ${taskCounts.inProgress} in-progress, ${taskCounts.done} done)`;
                } else {
                    nameSpan.textContent = `${currentNode.name} (${completionPercentage}%)`;
                }

                nameSpan.style.cursor = 'pointer';
                nodeDiv.appendChild(nameSpan);

                let clickTimeout = null;
                nodeDiv.onclick = (e) => {
                    e.stopPropagation();

                    // Clear any pending click timeout to prevent focus conflict with double-click
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                    }

                    // Delay the focus to allow double-click to cancel it
                    clickTimeout = setTimeout(() => {
                        if (selectedNode !== currentNode) {
                            selectedNode = currentNode;
                            renderView();
                        }
                        // Refocus the task list div for keyboard navigation
                        document.getElementById('tasklist').focus();
                        clickTimeout = null;
                    }, 200);
                };

                // Double-click to edit inline
                nameSpan.ondblclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    // Cancel the pending click timeout
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                    }

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = currentNode.name;
                    input.style.flex = '1';
                    input.style.fontSize = '0.95em';
                    input.style.padding = '4px';

                    const saveEdit = () => {
                        if (input.value.trim()) {
                            currentNode.name = input.value.trim();
                            saveState();
                            renderView();
                        } else {
                            renderView();
                        }
                    };

                    input.onblur = saveEdit;
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveEdit();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            renderView();
                        }
                    };

                    nameSpan.replaceWith(input);
                    // Use setTimeout to ensure focus happens after the click event completes
                    setTimeout(() => {
                        input.focus();
                        input.select();
                    }, 0);
                };

                // Add actions container on the right
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'node-actions';

                // Add status dropdown for leaf nodes
                if (currentNode.isLeaf) {
                    const statusSelect = document.createElement('select');
                    ['new', 'in-progress', 'done'].forEach(status => {
                        const option = document.createElement('option');
                        option.value = status;
                        option.text = status;
                        if (status === currentNode.status) option.selected = true;
                        statusSelect.appendChild(option);
                    });
                    statusSelect.onclick = (e) => {
                        e.stopPropagation();
                    };
                    statusSelect.onchange = (e) => {
                        e.stopPropagation();
                        currentNode.status = e.target.value;
                        updateParentStatuses(taskList);
                        saveState();
                        renderView();
                        // Refocus for keyboard navigation
                        setTimeout(() => document.getElementById('tasklist').focus(), 0);
                    };
                    actionsDiv.appendChild(statusSelect);
                }

                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeChild(currentNode);
                    renderView();
                    // Refocus for keyboard navigation
                    setTimeout(() => document.getElementById('tasklist').focus(), 0);
                };
                actionsDiv.appendChild(removeBtn);

                nodeDiv.appendChild(actionsDiv);
                container.appendChild(nodeDiv);

                // Add description if it exists
                if (currentNode.description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'node-description visible';
                    descDiv.style.marginLeft = `${currentDepth * 20 + 5}px`;
                    descDiv.textContent = currentNode.description;
                    container.appendChild(descDiv);
                }

                if (!currentNode.isLeaf && !currentNode.collapsed) {
                    currentNode.children.forEach(child => {
                        const childElement = createNodeElement(child, currentDepth + 1);
                        if (childElement) {
                            container.appendChild(childElement);
                        }
                    });
                }

                return container;
            }

            const rootElement = createNodeElement(node, depth);
            if (rootElement) {
                element.appendChild(rootElement);
            }
            updateStats();
            updateUndoRedoButtons();
        }

        function updateParentStatuses(node) {
            if (!node.isLeaf) {
                node.status = node.calculateStatus();
                node.children.forEach(child => updateParentStatuses(child));
            }
        }

        function findParent(root, target) {
            if (root.children.includes(target)) return root;
            for (let child of root.children) {
                const parent = findParent(child, target);
                if (parent) return parent;
            }
            return null;
        }

        function areSiblings(node1, node2) {
            const parent1 = findParent(taskList, node1);
            const parent2 = findParent(taskList, node2);
            return parent1 === parent2 && parent1 !== null;
        }

        // Arrow navigation helpers
        function getSiblings(node) {
            if (node === taskList) return [taskList];
            const parent = findParent(taskList, node);
            return parent ? parent.children : [taskList];
        }

        function navigateToNextSibling() {
            if (!selectedNode) return;
            const siblings = getSiblings(selectedNode);
            const currentIndex = siblings.indexOf(selectedNode);
            if (currentIndex < siblings.length - 1) {
                selectedNode = siblings[currentIndex + 1];
                renderView();
            }
        }

        function navigateToPreviousSibling() {
            if (!selectedNode) return;
            const siblings = getSiblings(selectedNode);
            const currentIndex = siblings.indexOf(selectedNode);
            if (currentIndex > 0) {
                selectedNode = siblings[currentIndex - 1];
                renderView();
            }
        }

        function navigateToParent() {
            if (!selectedNode || selectedNode === taskList) return;
            const parent = findParent(taskList, selectedNode);
            if (parent) {
                selectedNode = parent;
                renderView();
            }
        }

        function navigateToFirstChild() {
            if (!selectedNode) return;
            if (!selectedNode.isLeaf && selectedNode.children.length > 0) {
                // Expand the node if it's collapsed
                if (selectedNode.collapsed) {
                    selectedNode.collapsed = false;
                }
                selectedNode = selectedNode.children[0];
                renderView();
            }
        }

        // Node reordering functions
        function moveNodeUp() {
            if (!selectedNode || selectedNode === taskList) return;
            const parent = findParent(taskList, selectedNode);
            if (!parent) return;

            const siblings = parent.children;
            const currentIndex = siblings.indexOf(selectedNode);

            if (currentIndex > 0) {
                // Swap with previous sibling
                [siblings[currentIndex - 1], siblings[currentIndex]] =
                [siblings[currentIndex], siblings[currentIndex - 1]];

                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
        }

        function moveNodeDown() {
            if (!selectedNode || selectedNode === taskList) return;
            const parent = findParent(taskList, selectedNode);
            if (!parent) return;

            const siblings = parent.children;
            const currentIndex = siblings.indexOf(selectedNode);

            if (currentIndex < siblings.length - 1) {
                // Swap with next sibling
                [siblings[currentIndex], siblings[currentIndex + 1]] =
                [siblings[currentIndex + 1], siblings[currentIndex]];

                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
        }

        function moveNodeToFirst() {
            if (!selectedNode || selectedNode === taskList) return;
            const parent = findParent(taskList, selectedNode);
            if (!parent) return;

            const siblings = parent.children;
            const currentIndex = siblings.indexOf(selectedNode);

            if (currentIndex > 0) {
                // Remove from current position and insert at beginning
                const node = siblings.splice(currentIndex, 1)[0];
                siblings.unshift(node);

                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
        }

        function moveNodeToLast() {
            if (!selectedNode || selectedNode === taskList) return;
            const parent = findParent(taskList, selectedNode);
            if (!parent) return;

            const siblings = parent.children;
            const currentIndex = siblings.indexOf(selectedNode);

            if (currentIndex < siblings.length - 1) {
                // Remove from current position and insert at end
                const node = siblings.splice(currentIndex, 1)[0];
                siblings.push(node);

                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
        }

        function addNode() {
            if (!selectedNode) {
                alert('Please select a parent node first');
                return;
            }
            addChild(selectedNode);
        }

        function addChild(node) {
            const name = prompt('Enter node name:');
            if (name) {
                const newNode = new Node(name);
                if (node.isLeaf) {
                    node.isLeaf = false;
                    node.status = 'new';
                }
                node.children.push(newNode);
                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
            // Refocus for keyboard navigation
            setTimeout(() => document.getElementById('tasklist').focus(), 0);
        }

        function renameNode() {
            if (!selectedNode) {
                alert('Please select a node to rename');
                return;
            }
            const newName = prompt('Enter new node name:', selectedNode.name);
            if (newName && newName.trim()) {
                selectedNode.name = newName.trim();
                saveState();
                renderView();
            } else if (newName !== null) {
                alert('Node name cannot be empty');
            }
            // Refocus for keyboard navigation
            setTimeout(() => document.getElementById('tasklist').focus(), 0);
        }

        function addDescription() {
            if (!selectedNode) {
                alert('Please select a node first');
                return;
            }
            const description = prompt('Enter node description:', selectedNode.description || '');
            if (description !== null) {
                selectedNode.description = description;
                saveState();
                renderView();
            }
            // Refocus for keyboard navigation
            setTimeout(() => document.getElementById('tasklist').focus(), 0);
        }

        function removeNode() {
            if (!selectedNode) {
                alert('Please select a node to remove');
                return;
            }
            if (selectedNode === taskList) {
                alert('Cannot remove the root node');
                return;
            }
            removeChild(selectedNode);
        }

        function removeChild(node) {
            if (!confirm(`Are you sure you want to remove "${node.name}" and all its children?`)) {
                return;
            }

            function removeFromParent(parent) {
                const index = parent.children.indexOf(node);
                if (index !== -1) {
                    parent.children.splice(index, 1);
                    if (parent.children.length === 0) {
                        parent.isLeaf = true;
                        parent.status = 'new';
                    }
                    updateParentStatuses(taskList);
                    saveState();
                    node = null;
                    renderView();
                } else {
                    parent.children.forEach(child => removeFromParent(child));
                }
            }

            removeFromParent(taskList);
        }

        function exportToJson() {
            const json = JSON.stringify(taskList, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${getActiveProjectName()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function convertToNode(obj) {
            const node = new Node(
                obj.name,
                obj.isLeaf,
                obj.children ? obj.children.map(convertToNode) : [],
                obj.collapsed || false,
                obj.description || ''
            );
            node.status = obj.status || 'new';
            return node;
        }

        function importFromJson() {
            const file = document.getElementById('importFile').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const jsonData = JSON.parse(e.target.result);
                        taskList = convertToNode(jsonData);
                        updateParentStatuses(taskList);
                        selectedNode = null;
                        saveState();
                        renderView();
                        renderProjectSelect();
                    } catch (error) {
                        alert('Error importing JSON: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        // Help Modal functions
        function openHelpModal() {
            const modal = document.getElementById('helpModal');
            if (modal) {
                modal.classList.add('visible');
            }
        }

        function closeHelpModal() {
            const modal = document.getElementById('helpModal');
            if (modal) {
                modal.classList.remove('visible');
            }
            // Refocus the task list for keyboard navigation
            setTimeout(() => document.getElementById('tasklist').focus(), 0);
        }

        // Close modal when clicking outside the content
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('helpModal');
            if (modal && e.target === modal) {
                closeHelpModal();
            }
        });
        // localStorage persistence
        function loadSavedState() {
            const saved = localStorage.getItem(currentKey());
            if (saved) {
                try {
                    taskList = convertToNode(JSON.parse(saved));
                    updateParentStatuses(taskList);
                } catch (e) { /* ignore corrupt data */ }
            }
        }

        // Snapshots
        function getSnapshots() {
            try {
                return JSON.parse(localStorage.getItem(snapshotsKey()) || '[]');
            } catch (e) {
                return [];
            }
        }

        function countTasks(node) {
            if (node.isLeaf) return 1;
            return node.children.reduce((sum, child) => sum + countTasks(child), 0);
        }

        function saveSnapshot() {
            const input = document.getElementById('snapshotName');
            const name = input.value.trim() || new Date().toLocaleString();
            const snapshots = getSnapshots();
            snapshots.push({
                id: Date.now(),
                name: name,
                date: new Date().toISOString(),
                data: JSON.stringify(taskList),
                taskCount: countTasks(taskList)
            });
            localStorage.setItem(snapshotsKey(), JSON.stringify(snapshots));
            input.value = '';
            renderSnapshotList();
        }

        function deleteSnapshot(id) {
            const snapshots = getSnapshots().filter(s => s.id !== id);
            localStorage.setItem(snapshotsKey(), JSON.stringify(snapshots));
            renderSnapshotList();
        }

        function restoreSnapshot(id) {
            const snapshot = getSnapshots().find(s => s.id === id);
            if (!snapshot) return;
            taskList = convertToNode(JSON.parse(snapshot.data));
            updateParentStatuses(taskList);
            selectedNode = null;
            saveState();
            renderView();
            renderSnapshotList();
        }

        function formatSnapshotDate(iso) {
            const d = new Date(iso);
            return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function renderSnapshotList() {
            const container = document.getElementById('snapshotList');
            if (!container) return;
            const snapshots = getSnapshots().slice().reverse();
            if (!snapshots.length) {
                container.innerHTML = '<div style="color:#6c757d; font-size:11px; padding:4px 0;">No snapshots yet</div>';
                return;
            }
            container.innerHTML = snapshots.map(s => `
                <div class="snapshot-item">
                    <div class="snapshot-info">
                        <span class="snapshot-name" title="${s.name}">${s.name}</span>
                        <span class="snapshot-meta">${formatSnapshotDate(s.date)} &middot; ${s.taskCount} task${s.taskCount !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="snapshot-actions">
                        <button onclick="restoreSnapshot(${s.id})" title="Restore">‚Ü©</button>
                        <button onclick="deleteSnapshot(${s.id})" title="Delete">üóë</button>
                    </div>
                </div>
            `).join('');
        }

        // Project management
        function getProjects() {
            try {
                return JSON.parse(localStorage.getItem('stepwise_projects') || '[]');
            } catch (e) {
                return [];
            }
        }

        function saveProjects(projects) {
            localStorage.setItem('stepwise_projects', JSON.stringify(projects));
        }

        function getActiveProjectName() {
            const project = getProjects().find(p => p.id === activeProjectId);
            return project ? project.name : 'Project';
        }

        function touchProjectModified() {
            const projects = getProjects();
            const project = projects.find(p => p.id === activeProjectId);
            if (project) {
                project.lastModified = new Date().toISOString();
                saveProjects(projects);
            }
        }

        function initProjects() {
            const projects = getProjects();
            if (projects.length > 0) {
                // Restore active project
                const savedActive = localStorage.getItem('stepwise_active_project');
                const found = projects.find(p => String(p.id) === String(savedActive));
                activeProjectId = found ? found.id : projects[0].id;
                localStorage.setItem('stepwise_active_project', activeProjectId);
                loadSavedState();
            } else {
                // Migrate old flat keys or start fresh
                const id = Date.now();
                const oldCurrent = localStorage.getItem('stepwise_current');
                const oldSnapshots = localStorage.getItem('stepwise_snapshots');
                const newProject = { id, name: 'Default', lastModified: new Date().toISOString() };
                saveProjects([newProject]);
                activeProjectId = id;
                localStorage.setItem('stepwise_active_project', id);
                if (oldCurrent) {
                    localStorage.setItem(currentKey(), oldCurrent);
                    localStorage.removeItem('stepwise_current');
                }
                if (oldSnapshots) {
                    localStorage.setItem(snapshotsKey(), oldSnapshots);
                    localStorage.removeItem('stepwise_snapshots');
                }
                loadSavedState();
            }
        }

        function renderProjectSelect() {
            const select = document.getElementById('projectSelect');
            if (!select) return;
            const projects = getProjects();
            select.innerHTML = projects.map(p =>
                `<option value="${p.id}"${p.id === activeProjectId ? ' selected' : ''}>${p.name}</option>`
            ).join('');
        }

        function createNewProject() {
            const name = prompt('Project name:', 'New Project');
            if (!name || !name.trim()) return;
            const id = Date.now();
            const projects = getProjects();
            projects.push({ id, name: name.trim(), lastModified: new Date().toISOString() });
            saveProjects(projects);
            activeProjectId = id;
            localStorage.setItem('stepwise_active_project', id);
            taskList = new Node('Root', false);
            history = [];
            historyIndex = -1;
            selectedNode = taskList;
            saveState();
            renderView();
            renderProjectSelect();
            renderSnapshotList();
        }

        function renameCurrentProject() {
            const current = getActiveProjectName();
            const name = prompt('New project name:', current);
            if (!name || !name.trim()) return;
            const projects = getProjects();
            const project = projects.find(p => p.id === activeProjectId);
            if (project) {
                project.name = name.trim();
                saveProjects(projects);
                renderProjectSelect();
            }
        }

        function deleteCurrentProject() {
            const name = getActiveProjectName();
            if (!confirm(`Delete project "${name}"? This cannot be undone.`)) return;
            localStorage.removeItem(currentKey());
            localStorage.removeItem(snapshotsKey());
            let projects = getProjects().filter(p => p.id !== activeProjectId);
            if (projects.length === 0) {
                const id = Date.now();
                projects = [{ id, name: 'Default', lastModified: new Date().toISOString() }];
            }
            saveProjects(projects);
            activeProjectId = projects[0].id;
            localStorage.setItem('stepwise_active_project', activeProjectId);
            taskList = new Node('Root', false);
            history = [];
            historyIndex = -1;
            loadSavedState();
            selectedNode = taskList;
            saveState();
            renderView();
            renderProjectSelect();
            renderSnapshotList();
        }

        function switchProject(id) {
            id = typeof id === 'string' ? parseInt(id, 10) : id;
            if (id === activeProjectId) return;
            activeProjectId = id;
            localStorage.setItem('stepwise_active_project', id);
            taskList = new Node('Root', false);
            history = [];
            historyIndex = -1;
            loadSavedState();
            selectedNode = taskList;
            saveState();
            renderView();
            renderProjectSelect();
            renderSnapshotList();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // ESC - Close help modal
            if (e.key === 'Escape') {
                const modal = document.getElementById('helpModal');
                if (modal && modal.classList.contains('visible')) {
                    e.preventDefault();
                    closeHelpModal();
                    return;
                }
            }

            // Ctrl+H - Open help modal
            if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                openHelpModal();
                return;
            }

            // Ignore if typing in an input or textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            // Ctrl+Z - Undo
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y - Redo
            else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
            // Ctrl+F - Focus search
            else if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.getElementById('searchBox').focus();
            }
            // Enter - Add child node
            else if (e.key === 'Enter' && selectedNode) {
                e.preventDefault();
                addNode();
            }
            // F2 - Rename node
            else if (e.key === 'F2' && selectedNode) {
                e.preventDefault();
                renameNode();
            }
            // Delete - Remove node
            else if (e.key === 'Delete' && selectedNode) {
                e.preventDefault();
                removeNode();
            }
            // Ctrl+Shift+Up - Move node up in sibling list
            else if (e.ctrlKey && e.shiftKey && e.key === 'ArrowUp' && selectedNode) {
                e.preventDefault();
                moveNodeUp();
            }
            // Ctrl+Shift+Down - Move node down in sibling list
            else if (e.ctrlKey && e.shiftKey && e.key === 'ArrowDown' && selectedNode) {
                e.preventDefault();
                moveNodeDown();
            }
            // Ctrl+Shift+Home - Move node to first position
            else if (e.ctrlKey && e.shiftKey && e.key === 'Home' && selectedNode) {
                e.preventDefault();
                moveNodeToFirst();
            }
            // Ctrl+Shift+End - Move node to last position
            else if (e.ctrlKey && e.shiftKey && e.key === 'End' && selectedNode) {
                e.preventDefault();
                moveNodeToLast();
            }
            // Arrow Up - Navigate to previous sibling
            else if (e.key === 'ArrowUp' && selectedNode) {
                e.preventDefault();
                navigateToPreviousSibling();
            }
            // Arrow Down - Navigate to next sibling
            else if (e.key === 'ArrowDown' && selectedNode) {
                e.preventDefault();
                navigateToNextSibling();
            }
            // Arrow Left - Navigate to parent (out of depth level)
            else if (e.key === 'ArrowLeft' && selectedNode) {
                e.preventDefault();
                navigateToParent();
            }
            // Arrow Right - Navigate to first child (into depth level)
            else if (e.key === 'ArrowRight' && selectedNode) {
                e.preventDefault();
                navigateToFirstChild();
            }
            // Space - Toggle expand/collapse for nodes with children
            else if (e.key === ' ' && selectedNode) {
                e.preventDefault();
                if (!selectedNode.isLeaf && selectedNode.children.length > 0) {
                    selectedNode.collapsed = !selectedNode.collapsed;
                    renderView();
                }
            }
            // 1 - Set status to 'new' (only for leaf nodes)
            else if (e.key === '1' && selectedNode && selectedNode.isLeaf) {
                e.preventDefault();
                selectedNode.status = 'new';
                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
            // 2 - Set status to 'in-progress' (only for leaf nodes)
            else if (e.key === '2' && selectedNode && selectedNode.isLeaf) {
                e.preventDefault();
                selectedNode.status = 'in-progress';
                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
            // 3 - Set status to 'done' (only for leaf nodes)
            else if (e.key === '3' && selectedNode && selectedNode.isLeaf) {
                e.preventDefault();
                selectedNode.status = 'done';
                updateParentStatuses(taskList);
                saveState();
                renderView();
            }
        });

        window.onload = function() {
            if (!document.getElementById('tasklist')) {
                console.error('Task list container not found on page load');
                return;
            }
            initProjects(); // initialize projects, migrate old data, load active project state
            selectedNode = taskList; // Set initial selection to root node
            saveState(); // Save initial state
            renderView();
            renderProjectSelect();
            renderSnapshotList();
            // Focus the task list div so keyboard events work
            document.getElementById('tasklist').focus();
        };
    </script>
</body>
</html>